---
inclusion: always
---

# Development Workflow for DBSurveyor

## Core Development Rules

### Security-First Requirements (NON-NEGOTIABLE)

- **NEVER** log database connection strings or credentials
- **ALWAYS** use read-only database operations (SELECT/DESCRIBE only)
- **ALWAYS** sanitize credentials in error messages and logs
- **ALWAYS** validate offline operation (no external network calls except to target databases)
- **ALWAYS** use AES-GCM with unique-per-key 96-bit nonce generated by CSPRNG
- **NEVER** reuse nonces for the same key
- **ALWAYS** store/transport nonce alongside ciphertext (or derive deterministically per-record with secure scheme)

### Code Quality Gates (MANDATORY)

- Zero warnings policy: `cargo clippy -- -D warnings` must pass
- Test coverage >80%: `just coverage` must pass
- All public APIs must have `///` documentation
- Use `Result<T, E>` for all error handling with `?` operator
- Follow Repository/Service patterns for database access

## Essential Commands

### Primary Development Workflow

```bash
just dev                 # Complete development cycle (format, lint, test, coverage)
just format             # Format code with rustfmt
just lint               # Run clippy with zero warnings policy
just test               # Run full test suite with security verification
just coverage           # Generate coverage report (>80% required)
just security-full      # Complete security validation suite
just ci-check           # Run CI-equivalent checks locally
```

### Security Validation (REQUIRED)

```bash
just test-credential-security  # Verify no credential leakage
just test-encryption          # Test AES-GCM encryption
just test-offline            # Verify airgap compatibility
just security-audit          # SBOM + vulnerability scan
```

### Database Testing

```bash
just test-postgres      # PostgreSQL adapter tests
just test-mysql         # MySQL adapter tests
just test-sqlite        # SQLite adapter tests
```

## Code Patterns (MANDATORY)

### Error Handling

```rust
// ✅ REQUIRED: Use thiserror with sanitized messages
#[derive(Debug, thiserror::Error)]
pub enum CollectorError {
    #[error("Database connection failed")]  // Never include credentials
    Connection(#[from] sqlx::Error),

    #[error("Schema collection failed: {context}")]
    Collection { context: String },
}

// ✅ REQUIRED: Proper Result handling
pub async fn collect_schema(url: &str) -> Result<DatabaseSchema, CollectorError> {
    let pool = create_pool(url).await?;  // Use ? operator
    let schema = extract_schema(&pool).await?;
    Ok(schema)
}
```

### Repository Pattern (REQUIRED)

```rust
#[async_trait]
pub trait SchemaCollector {
    type Error: std::error::Error + Send + Sync + 'static;

    fn new(connection_string: &str) -> Result<Self, Self::Error> where Self: Sized;
    async fn collect_schema(&self) -> Result<DatabaseSchema, Self::Error>;
    async fn test_connection(&self) -> Result<(), Self::Error>;
}
```

### Documentation (REQUIRED)

```rust
/// Collects database schema with security guarantees.
///
/// # Security
/// - Credentials never logged or stored
/// - Read-only operations only
/// - Connection strings sanitized in errors
///
/// # Arguments
/// * `database_url` - Connection string (will be sanitized)
///
/// # Errors
/// Returns error if connection fails or insufficient privileges
pub async fn collect_schema(database_url: &str) -> Result<DatabaseSchema> {
    // Implementation
}
```

### Credential Redaction Helper (REQUIRED)

```rust
/// Safely parses and redacts database URLs for logging and error messages.
///
/// This function ensures that passwords in connection strings are never
/// exposed in logs, error messages, or any output.
///
/// # Arguments
///
/// * `url` - Database connection URL that may contain credentials
///
/// # Returns
///
/// Returns a sanitized string with passwords masked as "****"
///
/// # Example
///
/// ```rust
/// let sanitized = redact_database_url("postgres://user:secret@localhost/db");
/// assert_eq!(sanitized, "postgres://user:****@localhost/db");
/// assert!(!sanitized.contains("secret"));
/// ```
pub fn redact_database_url(url: &str) -> String {
    match url::Url::parse(url) {
        Ok(mut parsed_url) => {
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("****")).ok();
            }
            parsed_url.to_string()
        }
        Err(_) => "<redacted>".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_redact_database_url() {
        let url = "postgres://user:secret@localhost/db";
        let redacted = redact_database_url(url);

        assert!(!redacted.contains("secret"));
        assert!(!redacted.contains("user:secret"));
        assert!(redacted.contains("user:****"));
        assert!(redacted.contains("localhost/db"));
    }
}
```

## Testing Requirements

### Unit Tests (MANDATORY)

```rust
#[test]
fn test_credential_sanitization() {
    let config = DatabaseConfig::new("postgres://user:secret@host/db");
    let output = config.safe_display();
    assert!(!output.contains("secret"));
}
```

### Integration Tests (REQUIRED)

```rust
#[tokio::test]
async fn test_postgres_integration() {
    // Use testcontainers for real database testing
    let docker = testcontainers::clients::Cli::default();
    let postgres = docker.run(testcontainers::images::postgres::Postgres::default());
    // Test implementation
}
```

### Security Tests (MANDATORY)

```rust
#[tokio::test]
async fn test_no_credentials_in_output() -> Result<(), Box<dyn std::error::Error>> {
    let schema = collect_schema("postgres://user:secret@localhost/db").await?;
    let json = serde_json::to_string(&schema)?;
    assert!(!json.contains("secret"));
    Ok(())
}
```

## Performance Requirements

### Database Operations

- Connection pooling: 5-10 connections max
- Query timeouts: 30 seconds default (Postgres: statement_timeout, MySQL: max_execution_time, SQLite: busy_timeout)
- Enforce read-only at connection/user level (Postgres: revoke/grant or connection flags, MySQL: GRANT SELECT, SQLite: immutable/open flags)
- Stream large result sets (don't load into memory)
- Use prepared statements for repeated queries

### Memory Management

- Use `Arc<T>` for shared immutable data
- Implement explicit `drop()` for large structures
- Stream processing for files >10MB
- Monitor memory in benchmarks

## Pre-Commit Checklist

Before any commit:

- [ ] `just lint` passes (zero warnings)
- [ ] `just test` passes (all tests)
- [ ] `just security-full` passes (security validation)
- [ ] `just coverage` >80% (coverage threshold)
- [ ] No credentials in logs/outputs
- [ ] Offline operation verified

## Anti-Patterns (NEVER DO)

### Security Anti-Patterns

```rust
// ❌ NEVER: Log connection strings
log::info!("Connecting to {}", database_url);

// ❌ NEVER: Include credentials in errors
#[error("Failed to connect to {url}")]
ConnectionError { url: String },

// ❌ NEVER: Store credentials in structs
pub struct Config {
    pub password: String,  // FORBIDDEN
}
```

### Rust Anti-Patterns

```rust
// ❌ NEVER: Use unwrap in production
let result = operation().unwrap();

// ❌ NEVER: Ignore clippy warnings
#[allow(clippy::all)]  // FORBIDDEN

// ❌ NEVER: String concatenation for SQL
let query = format!("SELECT * FROM {}", table);  // Use parameterized queries
```

## Architecture Compliance

### Required Patterns

- Repository pattern for database access
- Factory pattern for collector instantiation
- Command pattern for CLI (using clap derive)
- Service pattern for business logic

### Workspace Structure

- `dbsurveyor-collect/`: Database collection binary
- `dbsurveyor/`: Report generation binary
- `dbsurveyor-core/`: Shared library (models, encryption, utilities)
